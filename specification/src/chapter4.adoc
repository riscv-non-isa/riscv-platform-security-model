[[chapter4]]

== Use case examples

=== Basic non-virtualized system

==== Overview

==== Secure and Verified Boot

==== Isolation model

==== Device access control

==== Sealing

==== Attestation


=== Basic virtualized system

==== Overview

==== Isolation model

==== Device access control

==== Sealing

==== Attestation


=== Global Platform TEE

==== Overview

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title= "Global platform TEE use cases"]
image::img_ch4_gp-tee.png[]

https://globalplatform.org/[Global platform] defines technical standards, interface specifications and programming models, open source firmware, and certification programmes for _trusted execution environments (TEE)_. 

A TEE is an isolated environment providing security services to other software on the same Hart. For example:

* Payment clients
* DRM clients and content protection
* Secure storage
* User identity management
* Attestation services

The TEE model divides software into isolated domains:

* Normal domain +
Typically hosting a _rich OS_ (RTOS or Linux), and user applications. 
* TEE domain +
Hosts a _TEE OS_ (domain security manager) and _trusted applications (TA)_. 
* Root domain +
Hosts RoT firmware, including a secure monitor

The TEE OS is primarily responsible for isolation of TA, and for providing root of trust services, within the TEE domain.

The OS in normal domain typically controls scheduling on the Hart. To interact with TA services, the OS in normal mode interacts with the TEE OS through the secure monitor in root domain. 

The secure monitor is responsible for context switching and isolation across domain boundaries. 

For the purpose of this specification, commonly used TEE deployment models in existing ecosystems include:

* Static partition TEE +
A single TEE provides security services to normal domain. TA are typically installed at boot by RoT FW and TEE OS, though Global Platforms does also define protocols for installation of TA at runtime. System configuration and resource allocation can be mostly static, making the system more deterministic. +
 +
_Use case examples:_ edge devices and IoT, automation, and automotive. 
* Virtualized TEE +
On a virtualized system, TEE can also be virtualized. In this case a _secure partition manager_ in TEE domain is responsible for isolation of multiple TEE guests (for example, an OEM TEE and separate Guest TEE for third party providers). This model can be more dynamic, for example more dynamic resource allocation. +
 +
_Use case examples:_ mobile clients, and automotive.

==== Isolation model

A Global Platform TEE requires the following isolation guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN  
| Root domain MAY access resources assigned to any domain, but SHOULD prevent itself from unintended access to resources assigned to a different domain (privilege escalation).

| CAT_NNN
| No other domains can access resources assigned to Root domain

| CAT_NNN
| Resources assigned to TEE domain MUST NOT be accessible to normal domain

| CAT_NNN
| Resources assigned to normal domain MUST be accessible to normal domain (r/w/x), and to TEE domain (r/w) (default sharing rule)

| CAT_NNN
| Resources assigned to a single TA, or a guest TEE, MUST be private.

|===

The standard GP TEE model does not support sharing memory between TA in TEE domain. Each TA is expected to be a self-contained unit providing a specific security service, either to Normal domain or to other TA. All communications are implemented through secure channels managed by the TEE OS (and SPM in the case of a virtualized TEE). 

Processes in normal domain can share memory assigned to Normal domain when interacting with a TA in TEE world. Such shared memory can be cached when context switching between Normal and TEE domains (default sharing rule).

RISC-V hardware enforced isolation mechanisms can be used as follows to meet those guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| PMP/ePMP, or MTT, MUST be used to isolate Root domain from other domains.

| CAT_NNN  
| Supervisor domains MUST be used to enforce isolation between normal and TEE domains.

|===

NOTE: MTT can be sufficient for protecting Root domain in the sense that M-mode can enforce that its own resources are never assigned to another domain. PMP/ePMP still add further protections for M-mode, such as the ability to implement temporal isolation boundaries within M-mode (for example, protect early boot code), or to prevent itself from accessing or executing from memory assigned to lower privilege levels (privilege escalation).

See xref:chapter3.adoc#_Supervisor_domains[supervisor domains].

For static partition TEE, using PMP/ePMP or PMA with supervisor domains can be sufficient. 

For virtualized TEE, MTT should be used with supervisor domains.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| For a static partition TEE, sPMP or MMU MUST be used to enforce isolation between TA.
|===

For example: sPMP may be required for use cases with hard realtime requirements, and MMU may be required for Linux based systems.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| For a virtualized TEE, hypervisor extension MUST be supported

| CAT_NNN
| For a virtualized TEE, MMU MUST be used to enforce isolation between guest TEE, and between TA within a TEE.
|===

==== Root of Trust

See xref:chapter2.adoc#_Reference_model[reference model].

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| A TEE based system SHOULD implement a HW RoT

|===

==== Authorized boot

See xref:chapter2.adoc#_Ecosystem_security_objectives[authorized software].

TEE boot is typically based on:

* Measured and verified local boot (direct or indirect)
* Sealing, to protect TEE production assets

The process can involve multiple stages (layered boot). 

==== Attestation

See xref:chapter2.adoc#_Ecosystem_security_objectives[attestable services].

Static partition TEE attestation is typically based on a security platform attestation signed by a RoT.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
a| A security platform attestation MUST cover: 

* TEE domain
* Root domain
* Boot state of all trusted subsystems

|===

Virtualized TEE attestation can be layered, for performance or separation of concern. For example:

* A security platform attestation, signed by a RoT, covering trusted subsystems, Root domains, and SPM
* Separate guest TEE attestation(s) signed by SPM 

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
a| Layered attestations MUST be cryptographically bound such that a reliant party can determine that they 

* Were generated on the same system
* Are both fresh.  
|===

For example: hash locked together, including freshness supplied by the reliant party.

==== Device access control

For the purpose of this specification, a device can be a logical device. A physical device can present more than one logical devices, each with its own (logical) control interface. 

The security guarantees also apply to device initiated accesses, for example DMA and interrupts.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| A static partition TEE MUST use IOPMP to enforce access control rules for devices.

| CAT_NNN
| A virtualized TEE MUST use IOMTT and IOMMU to enforce access control rules for devices assigned to Normal or TEE domains, and SHOULD use IOPMP to enforce access control rules for Root devices.

| CAT_NNN
| IOPMP and IOMTT configurations MUST only be directly accessible by Root domain.

|===

For a static partition TEE, domain level granularity can be sufficient as device access within TEE and Normal domains is governed by TEE OS and the rich OS respectively. It can be implemented using IOPMP. Policy can be controlled by boot configuration (a RoT), or be hardwired at system level.

For a virtualized TEE, IOMTT enforces supervisor domain level access rules (physical isolation), and IOMMU enforces guest and TA level access rules (virtualization), supporting device assignment to a guest TEE or a TA. The IO subsystem of IOMTT and IOMMU has the capability of determining, through configuration managed by Root domain, which supervisor domain a device is assigned to. IOMTT is then able to apply the appropriate MTT access rules for any device initiated access, regardless of which domain is currently active on a Hart. 

NOTE: IOMTT can also be sufficient for protecting Root devices in the sense that M-mode can enforce that its own resources are never assigned to another domain. Use of IOPMP or similar still adds further protections. For example, a system may require that Root devices are not able to access memory assigned to TEE domain.

==== System integration

In the case of a Global Platform TEE system, the number and make-up of supervisor domains can be known, and a simple convention can be used for common identification of Normal, TEE, and Root domains across multiple Harts in a system. For example, by adopting a commonly used two-bit convention from an existing ecosystem (interoperability) which can be derived from SDID and privilege level.

System integration in this context involves providing _security attributes_ on the interconnect, tagging all transactions (CPU or system agent initiated) with such a domain ownership identity. 

Possible use cases include:

* Driving cryptographic memory protection
* Tagging in cache coherent memory subsystems
* Device assignment (IOPMP/IOMTT integration)

Security attributes can be reflected alongside other identities, such as a confidential guest ID.

==== Sealing



=== Confidential computing on RISC-V (CoVE)
==== Overview
[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title= "Global platform TEE use cases"]
image::img_ch4_cove.png[]

In hosting environments, tenant workloads rely on isolation primitives that are managed by host privileged software. This can lead to a large TCB for tenants which could include, for example, a hypervisor, orchestration services, and host management services. It could also include other tenants exploiting vulnerabilities in complex hosting software.

Confidential compute aims to achieve a minimal and certifiable TCB for _confidential workloads_. 

_CoVE (Confidential VM Extensions)_ https://github.com/riscv-non-isa/riscv-ap-tee/tree/main/specification[specification] defines a confidential compute platform for RISC-V systems, including interfaces and programming models, covering lifecycle management, attestation, resource management and devices assignment, for confidential workloads. It is based on principles defined by https://confidentialcomputing.io/[Confidential Computing Consortium]. Reference firmware for CoVE is being developed as part of the https://riseproject.dev/[Risc-V Software Ecosystem] project.

CoVE divides software on a Hart in three domains:

* Normal domain +
Typically hosting a hypervisor, and normal guests and services. 
* Confidential domain +
Hosts a _TSM_ (domain security manager) and confidential workloads.
* Root domain +
Hosts RoT firmware, including a _secure monitor_ 

The TSM is primarily responsible for isolation of confidential workloads, and for providing RoT services, within the confidential domain.

A hypervisor in normal domain typically controls scheduling and resource assignment on the Hart. It interacts with the TSM through the secure monitor in root domain to manage confidential workloads. 

The secure monitor is responsible for context switching and isolation across domain boundaries.

==== Isolation model

Confidential workloads are provided the following isolation guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN  
| Root domain MAY access resources assigned to any domain, but SHOULD prevent itself from unintended access to resources assigned to a different domain (privilege escalation).

| CAT_NNN
| No other domain can access resources assigned to Root domain

| CAT_NNN
| Resource assigned only to either Confidential or Normal domains MUST be private.

| CAT_NNN
| Resources MAY be assigned to both normal and confidential domains (sharing by consent).

| CAT_NNN
| Resources assigned to a single confidential workload MUST be private

| CAT_NNN
| Resources MAY be assigned to multiple confidential workloads (sharing by consent)

|===

RISC-V hardware enforced isolation mechanisms can be used as follows to meet those guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| PMP/ePMP or MTT MUST be used to isolate Root Domain from other domains.

|===

NOTE: MTT can be sufficient for protecting Root domain in the sense that M-mode can enforce that its own resources are never assigned to another domain. PMP/ePMP still add further protections for M-mode, such as the ability to implement temporal isolation boundaries within M-mode (for example, protect early boot code), or to prevent itself from accessing or executing from memory assigned to lower privilege levels (privilege escalation).

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| Hypervisor extension MUST be supported

| CAT_NNN
| MMU MUST be used to enforce isolation between confidential guests within Confidential domain.
|===

==== Root of trust

See xref:chapter2.adoc#_Reference_model[reference model].

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| A confidential compute system MUST implement a HW RoT

|===

==== Authorized Boot
See xref:chapter2.adoc#_Ecosystem_security_objectives[authorized software].

Confidential compute boot in a data centre context is typically based on:

* Measured boot of a hosting platform
* Platform attestation and security provisioning (unsealing) by a remote provisioning system
* Launch of a confidential environment, and confidential workloads, once the system has been unsealed

The process can involve multiple stages (layered boot). 

==== Attestation

See xref:chapter2.adoc#_Ecosystem_security_objectives[attested services].

Attestation for confidential compute is typically layered, for performance and separation of concern:

* A security platform attestation, signed by a hardware root of trust
* A confidential workload attestation, signed by TSM

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
a| A security platform attestation MUST cover: 

* TSM
* Root domain
* Boot state of all trusted subsystems

| CAT_NNN 
a| Layered attestations MUST be cryptographically bound such that a reliant party can determine that they 

* Were generated on the same system
* Are both fresh.  
|===

For example: hash locked together, including freshness supplied by the reliant party.

==== Device access control

For the purpose of this specification, a device can be a logical device. A physical device can present more than one logical devices, each with its own (logical) control interface. 

The security guarantees also apply to device initiated accesses, for example DMA and interrupts.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| IOMTT and IOMMU MUST be used to enforce access control rules for devices assigned to Normal or Confidential domains.

| CAT_NNN
| IOPMP SHOULD be used to enforce access control rules for Root devices.

| CAT_NNN
| IOPMP and IOMTT configurations MUST only be directly accessible by Root domain.

|===

IOMTT enforces supervisor domain level access rules (physical isolation), and IOMMU enforces guest and TA level access rules (virtualization), supporting device assignment to a confidential guest. The IO subsystem of IOMTT and IOMMU has the capability of determining, through configuration managed by Root domain, which supervisor domain a device is assigned to. IOMTT is then able to apply the appropriate MTT access rules for any device initiated access, regardless of which domain is currently active on a Hart. 

NOTE: IOMTT can also be sufficient for protecting Root devices in the sense that M-mode can enforce that its own resources are never assigned to another domain. Use of IOPMP or similar still adds further protections. For example, a system may require that Root devices are not able to access memory assigned to Confidential domain.

==== System integration

In the case of a confidential compute system, the number and make-up of supervisor domains can be known, and a simple convention can be used for common identification of Normal, Confidential, and Root domains across multiple Harts in a system. 

System integration in this context involves providing _security attributes_ on the interconnect, tagging all transactions (CPU or system agent initiated) with such a domain ownership identity. 

Possible use cases include:

* Driving cryptographic memory protection
* Tagging in cache coherent memory subsystems
* Device assignment (IOPMP/IOMTT integration)

Security attributes can be reflected alongside other identities, such as a confidential guest ID.

==== Trusted device assignment

==== Sealing

==== Debug, QoS and Performance Monitoring

=== Additional examples

(Variations on the above)

Android pKVM
